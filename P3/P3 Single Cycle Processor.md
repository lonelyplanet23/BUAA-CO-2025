# 单周期CPU 设计文档

1. 操作码对应信号
2. 控制信号
## IFU（取指令单元）

**模块描述：**
包含PC、NPC、IM三个子模块
（此处填写模块功能、内部结构、实现要点等）



###  PC（Program Counter）模块 

**模块功能简述：**

+ PC 模块保存当前执行的指令地址，在每个时钟周期根据控制信号更新为 next_PC 或保持不变

+ PC具有异步复位的功能，复位值为起始地址**0x00003000**

| 端口名       | 功能说明              | 位宽 | 方向 | 模块     |
| ------------ | --------------------- | ---- | ---- | -------- |
| **clk**      | 时钟信号              | 1    | I   | IFU      |
| **reset**    | 异步复位信号，清零 PC | 1    | I   | IFU      |
| **DI[31:0]** | 输入                  | 32   | I   | IFU      |
| **DO[31:0]** | 当前 PC 输出          | 32   | O     | IM / IFU |

### NPC(next program counter) 模块 
+ NPC模块根据当前PC模块输出的当前指令，计算下一条指令的地址
+ 如果是顺序执行类指令，则进行PC+4
+ 如果是分支指令beq
    + 
    + 若rs与rt相等(zero==1)，则输出PC+4+立即数；否则输出PC+4

| 端口名       | 功能说明              | 位宽 | 方向 | 连接模块     |
| ------------ | --------------------- | ---- | ---- | -------- |
| **PC[31:0]**      | 当前指令地址              | 32   | I   | PC      |
| **imm[15:0]**    | 16位的指令行偏移 | 16    | I   | IM      |
| **br** | beq分支指令标志     | 1   | I   | IM      | 
| **zero** | rs==rt         | 1   | I     | IM  |
| **NPC[31:0]** | 下一条指令地址 | 32 | I | PC |

### IM（Instruction Memory）模块 

**模块功能简述：**
 IM 模块根据输入的地址输出对应的机器指令，用 ROM 实现。
 + 容量为 4096（字 word） × 32bit，即存储了4096条指令(4096 =  2 ^ 12)
    + 所以ROM的地址宽度为12
+ 每个地址相差4，所以除以4（右移两位）可得到第几行指令

| 端口名      | 功能说明                   | 位宽 | 方向 | 连接模块 |
| ----------- | -------------------------- | ---- | ---- | -------- |
| **IM_addr[31:0]** | 指令地址输入（来自 PC）    |   32   |   I   | PC / IFU |
| **IM_data[31:0]** | 输出对应地址的指令内容     |   32   |   O   | IFU      |




---



## GRF（通用寄存器组）

**模块描述：**
（此处填写模块功能、读写端口设计、复位行为等）

### 模块接口

| 端口名     | 方向 | 位宽 | 功能说明 |
| :------ | :- | :- | :--- |
| `A1[4:0]`    |  I  |  5  |  读到RD1的地址    |
| `A2[4:0]`    |  I  |  5  |  读到RD2的地址    |
| `A3[4:0]`    |  I  |  5  |  写入地址    |
| `WD[31:0]`    |  I  |  5  |   写入数据   |
| `RD1[31:0]`   |  O |  32  |  读出的数据1     |
| `RD2[31:0]`   |  O  |  32  |  读出的数据2    |
| `WE`    |  I  |  1  |  写入使能信号    |
| `Clk`   |  I  |  1  |  时钟信号    |
| `Reset` |  I  |  1  | 异步复位     |

### 功能定义

| 功能项        | 
| :--------- | 
| 寄存器写入      | 
| 异步复位       | 
| 读出端口       |
| $0号寄存器常为0$ |

---

## ALU（算术逻辑单元）

**模块描述：**
支持 ADDU SUBU ORI LW SW BEQ 几个指令
集成方法：只需要使用加法、或者、判0模块即可

### 模块接口

| 端口名       | 方向 | 位宽 | 功能说明 |
| :-------- | :- | :- | :--- |
| `A[31:0]`       |  In  |  32  | 输入1    |
| `B[31:0]`       |  In  |  32  | 输入2    |
| `ALUCtrl[1:0]` |  In  |  2  | 控制信号     |
| `Result`  |  Out  |  1  |  结果    |
| `Zero`    | Out   |  1  |  是否相等    |

### 功能定义

| 功能项  | 功能描述 | 对应操作码
| :--- | :--- | :--- |
| 加法   |      | 000 |
| 减法   |      | 001 |
| 逻辑或  |      | 010 |
| 大小比较 |      | / |

---

## DM（数据存储器）

**模块描述：**
用于lw, sw指令。
存储程序的结果，能够读出存储器的数据
利用RAM实现，容量为3072 * 32bit，地址位宽为12
异步复位，初始化为0x00000000

### 模块接口

| 端口名        | 方向 | 位宽 | 功能说明 |
| :--------- | :- | :- | :--- |
| `Addr[4:0]`     | I   | 32   |  写入的地址  |
| `WD[31:0]`       |  I  |  32  |  写入的数据    |
| `RD[31:0]`       |  O  |  32  |  读出的数据    |
| `We` |  I  |   1  |   写使能信号   |
| `Clk`      |  I  |  1  |   时钟信号   |
|`reset`| I | 1 | 异步复位|

### 功能定义

| 功能项  | 
| :--- | 
| 读操作  |      
| 写操作  |      
| 写使能 |     
|异步复位|

---

## EXT（扩展单元）

**模块描述：**
将16位数进行0扩展为32位数

### 模块接口

| 端口名       | 方向 | 位宽 | 功能说明 |
| :-------- | :- | :- | :--- |
| `Imm16[15:0]`   |  I  |  16  |  16位输入    |
| `Ext[15:0]` |  I  |  16  |  32位0扩展结果    |


### 功能定义

| 功能项  | 功能描述 |
| :--- | :--- |
| 符号扩展 |  按照符号数进行扩展    |
| 零扩展  |   用0进行扩展   |

---

## Controller（控制器）

**模块描述：**
将机器指令的每一个信息，转化为CPU各部分的控制信号
拆解：
+ 和逻辑
+ 或逻辑

### 模块接口

| 端口名              | 方向 | 位宽 | 功能说明 |
| :--------------- | :- | :- | :--- |
| `Opcode`         |    |    |      |
| `Funct`          |    |    |      |
| `ControlSignals` |    |    |      |
| `Branch`         |    |    |      |

### 功能定义

| 功能项     | 功能描述 |
| :------ | :--- |
| 识别 |      |
| 主控制信号生成    |      |
| 运算控制    |      |

---


## 数据通路表

|    指令   |   `func`  |    `op`   | `RegDst` | `ALUSrc` | `MemtoReg` | `RegWrite` | `MemWrite` | `nPC_sel` | `ExtOp` | `ALUctr<2:0>` |    功能描述    |
| :-----: | :-------: | :-------: | :------: | :------: | :--------: | :--------: | :--------: | :-------: | :-----: | :-----------: | :--------: |
| **add** | `10 0000` | `00 0000` |     1    |     0    |      0     |      1     |      0     |     0     |    X    |      Add 000      |    R型加法    |
| **sub** | `10 0010` | `00 0000` |     1    |     0    |      0     |      1     |      0     |     0     |    X    |    Subtract 001   |    R型减法    |
| **ori** |    n/a    | `00 1101` |     0    |     1    |      0     |      1     |      0     |     0     |    0    |       Or  010    |    立即数或    |
|  **lw** |    n/a    | `10 0011` |     0    |     1    |      1     |      1     |      0     |     0     |    1    |      Add  000    |  读内存（Load） |
|  **sw** |    n/a    | `10 1011` |     X    |     1    |      X     |      0     |      1     |     0     |    1    |      Add  000    | 写内存（Store） |
| **beq** |    n/a    | `00 0100` |     X    |     0    |      X     |      0     |      0     |     1     |    X    |    Subtract 001   |   分支相等跳转   |

### 解释
| 信号名             | 全称                         | 含义                                   | 常见取值解释                                              |
| :-------------- | :------------------------- | :----------------------------------- | :-------------------------------------------------- |
| **RegDst**      | Register Destination       | 选择写回寄存器的目标：是 `rd`（R型）还是 `rt`（I型）。    | `1` → 写入 `rd`（如 add、sub）<br>`0` → 写入 `rt`（如 ori、lw） |
| **ALUSrc**      | ALU Source                 | 控制 ALU 第二个操作数来源：寄存器（rt）还是立即数（imm）。   | `0` → 来自寄存器（R型、beq）<br>`1` → 来自立即数（I型、lw、sw、ori）    |
| **MemtoReg**    | Memory to Register         | 控制写回寄存器的数据来自哪：ALU 结果还是内存。            | `0` → 写回 ALU 结果（add、sub、ori）<br>`1` → 写回内存（lw）      |
| **RegWrite**    | Register Write             | 是否允许写寄存器文件。                          | `1` → 启用写回（add、lw、ori）<br>`0` → 不写（sw、beq）          |
| **MemWrite**    | Memory Write               | 是否写入内存。                              | `1` → 写内存（sw）<br>`0` → 不写（其他）                       |
| **nPC_sel**     | Next PC select             | 控制下一个 PC 的来源：是 PC+4（顺序执行）还是分支目标（跳转）。 | `0` → 正常执行（PC+4）<br>`1` → 分支跳转（beq 并且条件满足）          |
| **ExtOp**       | Sign/Zero Extend Operation | 控制立即数扩展方式：符号扩展还是零扩展。                 | \          |
| **ALUctr<2:0>** | ALU Control                | 告诉 ALU 要执行什么运算。                      | 、<br>000=Add<br>001=Subtract<br>010=Or 等          |
