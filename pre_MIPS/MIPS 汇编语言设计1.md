# MIPS 汇编语言设计1



## MIPS `syscall` 常用速查表（MARS / SPIM 环境）

| `$v0` 值 | 功能说明                   | 参数寄存器                              | 示例                                                         |
| -------- | -------------------------- | --------------------------------------- | ------------------------------------------------------------ |
| **1**    | 打印整数                   | `$a0` = 要打印的整数                    | `asm<br>li $v0, 1<br>li $a0, 123<br>syscall`                 |
| **2**    | 打印浮点数（float）        | `$f12` = 要打印的浮点数                 | `asm<br>li $v0, 2<br>li.s $f12, 3.14<br>syscall`             |
| **3**    | 打印双精度浮点数（double） | `$f12` = double 高32位，`$f13` = 低32位 | （一般用 `ldc1` 装载）                                       |
| **4**    | 打印字符串                 | `$a0` = 字符串地址                      | `asm<br>li $v0, 4<br>la $a0, myMessage<br>syscall`           |
| **5**    | 读整数                     | 返回值存 `$v0`                          | `asm<br>li $v0, 5<br>syscall<br>move $t0, $v0`               |
| **6**    | 读浮点数（float）          | 返回到 `$f0`                            | `asm<br>li $v0, 6<br>syscall`                                |
| **7**    | 读双精度浮点数（double）   | 返回到 `$f0,$f1`                        |                                                              |
| **8**    | 读字符串                   | `$a0` = 缓冲区地址，`$a1` = 最大长度    | `asm<br>li $v0, 8<br>la $a0, buffer<br>li $a1, 20<br>syscall` |
| **9**    | 动态内存分配（sbrk）       | `$a0` = 请求字节数 → 返回地址存 `$v0`   |                                                              |
| **10**   | 退出程序                   | 无                                      | `asm<br>li $v0, 10<br>syscall`                               |

## TIPS

1. 编写标签-“函数”，jal jr $ra .text之下记得要退出程序
2. 单纯的浮点数常量是`double`类型
3. 区分 `add.d` (双浮点数) `add.s `(单浮点数)
4. 分支代码不是**函数**不需`jr $ra`
5. 一定要注意 `lw`(整数) `la`（地址，如字符串） `lwc1`(float) `ldc1`(double)
寄存器赋值注意

+ `lwc1 $f10, PI`  float类型
+ `ldc1 $f10, PI_double` double类型

输出检查:

+ v0指令对不对
+ add.d/add.s对不对
+ 多余的输出：有没有不需要输入输出、停止时，多打了`syscall`?




## 寄存器

在 MIPS 里，寄存器就是小的存储单元，用来放整数。常见的有：

- `$t0 ~ $t9` ：临时寄存器 (temporary)，程序里随便用。
- `$s0 ~ $s7` ：保存寄存器 (saved)，适合保存数据 -- 不允许修改
- `$a0 ~ $a3` ：参数寄存器 (argument)，经常用来给系统调用传值，例如输出
- `$v0 ~ $v1` ：返回值寄存器 (value)（函数返回值使用， 输入值），也用来装系统调用号(v0)(。
- `$0`: 常量0

### 浮点数的处理

在 MIPS 里，整数和浮点数存放在不同的寄存器里：

- 整数 → `$t0, $s0, …` 
- 浮点数 → `$f0, $f1, …`
  
储存浮点数要用
`lwc1 $f0, float_number`
`ldc1 $f0, double_number`

打印浮点数时要用：
- s for float and d for double
- `li $v0, 2` → 打印 **浮点数（单精度 float）**，**值要放在 `$f12`。**
  - `add.s $f12,$f1,$f2` 
- `li $v0, 3` → 打印 **浮点数（双精度 double）**，**值要放在 `$f12/$f13`（配对使用）。**
  - 双精度运算必须用 **偶数编号的寄存器**（`$f0, $f2, $f4 …`）。
  - `add.d $f12, $f0, $f2`

## 运算tips

使用 mult 或者 div（两个寄存器参数时）

- `HI`：这个寄存器用于乘除法。用来存放乘法结果的**的高 32 位**，或除法的**余数**
- `LO`：用来存放乘法结果的**低 32 位**，或除法的**商**
- 使用输出时，需要使用如下指令`mfhi 上$s0` `mflo $s1`

## 函数
+ 传参：使用`$v1`
+ 递归程序里，`$ra` 以及所保存的变量`$s0`需要放到 sp中s

## 分支结构
+ 分支下面的默认为 else
+ `slt`等： 将值1设为1或0，还需要再用`beq`进入分支
+ `bgt blt bge ble`: 集成了上面两者 

## 数组

`.space 8` 8字节的空间
`.word 100:9` 9个100
`.word 1, 2, 3, 4` 等同于 `a[4] = {1, 2, 3, 4}`

## 宏定义
	
  `.eqv	DATA_SIZE 4 # define integer - 4  double - 8`

```asm
    .macro macro_name(%parameter1, %parameter2, ...)
    # 代码段
    .end_macro
```