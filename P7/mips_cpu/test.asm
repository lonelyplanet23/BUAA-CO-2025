# P6 Simple Test Case
# 包含：乘法、MFHI/MFLO、SB/LB、基本的算术和转发

    ori  $t0, $0, 10        # 初始化 $t0 = 10
    ori  $t1, $0, 5         # 初始化 $t1 = 5
    ori  $s0, $0, 0         # 内存基地址设为 0

    # === 测试 1: 乘法与 HI/LO 读取 ===
    mult $t0, $t1           # $t0 * $t1 = 10 * 5 = 50 (HI=0, LO=50)
    
    # 在乘法计算期间插入无关指令，测试 MDU 是否并在后台运行
    add  $t2, $t0, $t1      # $t2 = 15 (不应被阻塞)
    sub  $t3, $t0, $t1      # $t3 = 5
    
    mflo $t4                # 取出 LO，预期 $t4 = 50 (0x32)。如果乘法没算完，这里应该阻塞。
    mfhi $t5                # 取出 HI，预期 $t5 = 0

    # === 测试 2: 按字节写 (SB) 与 读 (LB) ===
    # 将 0x12345678 拆开写入
    lui  $t6, 0x1234
    ori  $t6, $t6, 0x5678   # $t6 = 0x12345678
    
    # 写入内存地址 0, 1, 2, 3
    sb   $t6, 3($s0)        # 地址 3 写入 0x78 (由低位复制机制保证)
    srl  $t6, $t6, 8        # 移位
    sb   $t6, 2($s0)        # 地址 2 写入 0x56
    srl  $t6, $t6, 8
    sb   $t6, 1($s0)        # 地址 1 写入 0x34
    srl  $t6, $t6, 8
    sb   $t6, 0($s0)        # 地址 0 写入 0x12

    # 一次性读出来 (LW) 验证
    lw   $s1, 0($s0)        # 预期 $s1 = 0x78563412 (小端序内存: 12 34 56 78 -> 读出为 0x78563412)
    
    # 单独读字节 (LB) 并做符号扩展测试
    ori  $t7, $0, 0xFF      
    sb   $t7, 4($s0)        # 在地址 4 写入 0xFF (-1)
    lb   $s2, 4($s0)        # 读地址 4，预期 $s2 = 0xFFFFFFFF (符号扩展)

    # === 结束循环 ===
end:
    beq  $0, $0, end
    nop