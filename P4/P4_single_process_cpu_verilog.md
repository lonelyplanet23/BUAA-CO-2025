# 单周期 MIPS CPU 模块设计文档 (Verilog)

本项目基于 MIPS 架构的单周期实现，涵盖取指、译码、执行、访存和写回五个阶段所需的核心模块。

## verilog 提示 易错
1. 宏定义用法 使用前要加 `
2. 初始值为0 `32'h00000000`
3. IM: WE要在不reset的条件下触发；零寄存器保护；读操作不受时序逻辑控制，是组合逻辑
## 模块说明

### IFU (取指令单元) 

包含 PC、NPC、IM 三个子模块。

#### PC (Program Counter)

功能: 保存当前指令地址，并根据控制信号更新。同步复位至起始地址 0x00003000。


| 端口名 | 位宽 | 方向 | 功能说明 |
|---|---|---|---|
| clk | 1 | I | 时钟信号 |
| reset | 1 | I | 同步复位信号 |
| DI[31:0] | 32 | I | 下一条 PC 地址 (NPC) |
| DO[31:0] | 32 | O | 当前 PC 地址 |

#### NPC (Next Program Counter)

功能: 计算下一条指令地址 (PC+4 或分支目标地址)。

| 端口名 | 位宽 | 方向 | 功能说明 |
|---|---|---|---|
| PC[31:0] | 32 | I | 当前指令地址 |
| imm[25:0] | 26 | I | 26位立即数 |
| RA[31:0]  | 32 | I | 当前$31保存的寄存器地址|
| nPC_sel[1:0] | 2 | I | 下一 PC 选择信号(00=PC+4, 01=分支, 10= 跳转jal, 11 = 读取ra) |
| Zero | 1 | I | ALU Zero 标志 (用于 beq 条件判断) |
| NPC[31:0] | 32 | O | 下一条指令地址 |
| PC4[31:0] | 32 | O | 直接输出PC+4(jal) | 

#### IM (Instruction Memory)

功能: 根据地址输出对应的 32 位机器指令。容量 4096 * 32bit (地址位宽 12)。

| 端口名 | 位宽 | 方向 | 功能说明 |
|---|---|---|---|
| IM_addr[31:0] | 32 | I | 指令地址输入 (来自 PC) |
| IM_data[31:0] | 32 | O | 32位机器指令内容 |

### Splitter (指令译码/拆分)

功能: 将 32 位机器指令拆分为各个字段 (opcode, rs, rt, rd, shamt, funct, imm16)。


| 端口名 | 位宽 | 方向 | 字段/功能 | 对应位域 |
| ---- | ---- | ---- | ---- | ---- |
| Instr[31:0] | 32 | I | 32位机器指令 | N/A |
| opcode[5:0] | 6 | O | 操作码 | 31:26 |
| rs[4:0] | 5 | O | 源寄存器 1 | 25:21 |
| rt[4:0] | 5 | O | 源寄存器 2 / I型目标寄存器 | 20:16 |
| rd[4:0] | 5 | O | R型目标寄存器 | 15:11 |
| shamt[4:0] | 5 | O | 移位量 | 10:6 |
| funct[5:0] | 6 | O | 功能码 | 5:0 |
| imm16[15:0] | 16 | O | 16位立即数 | 15:0 |
| instr_index[25:0] | 26 | O | 25位立即数，JAL跳转 | 25:0|

### GRF (通用寄存器组)

功能: 包含 32 个 32 位寄存器，支持双端口读，单端口写。0号寄存器常为 0。

| 端口名 | 位宽 | 方向 | 功能说明 |
|---|---|---|---|
| A1[4:0] | 5 | I | 读端口 1 地址 |
| A2[4:0] | 5 | I | 读端口 2 地址 |
| RD1[31:0] | 32 | O | 读出的数据 1 |
| RD2[31:0] | 32 | O | 读出的数据 2 |
| A3[4:0] | 5 | I | 写入地址 |
| WD[31:0] | 32 | I | 写入数据 |
| WE | 1 | I | 写入使能信号 |
| Clk | 1 | I | 时钟信号 |
| Reset | 1 | I | 同步复位 |

###  ALU (算术逻辑单元)

功能: 执行加法、减法、逻辑或等运算，并输出零标志。

| 端口名 | 位宽 | 方向 | 功能说明 |
|---|---|---|---|
| A[31:0] | 32 | I | 输入操作数 1 |
| B[31:0] | 32 | I | 输入操作数 2 |
| ALUCtrl[2:0] | 3 | I | 运算控制信号 (000=Add, 001=Sub, 010=Or, 011=LUI/Shift) |
| Result[31:0] | 32 | O | 运算结果 |
| Zero | 1 | O | 零标志 (结果为 0 时为 1) |

###  DM (数据存储器)

功能: 用于 lw/sw 指令，实现数据读写。容量 3072 * 32bit。

| 端口名 | 位宽 | 方向 | 功能说明 |
|---|---|---|---|
| Addr[31:0] | 32 | I | 读/写地址 |
| WD[31:0] | 32 | I | 写入数据 |
| RD[31:0] | 32 | O | 读出数据 |
| We | 1 | I | 写使能信号 (MemWrite) |
| Clk | 1 | I | 时钟信号 |
| reset | 1 | I | 同步复位 |

###  EXT (立即数扩展单元)

功能: 将 16 位立即数扩展为 32 位 (符号扩展或零扩展)。

| 端口名 | 位宽 | 方向 | 功能说明 |
|---|---|---|---|
| Imm16[15:0] | 16 | I | 16位立即数输入 |
| ExtOp | 1 | I | 扩展操作选择 (1=符号扩展，0=零扩展) |
| Ext32[31:0] | 32 | O | 32位扩展结果 |

###  Controller (控制单元)

功能: 根据指令 Opcode 和 Funct 码，生成数据通路所需的所有控制信号。

| 端口名 | 位宽 | 方向 | 控制信号功能 |
|---|---|---|---|
| opcode[5:0] | 6 | I | 指令操作码 |
| funct[5:0] | 6 | I | R型指令功能码 |
| RegDst[1:0] | 2 | O | 目标寄存器选择 (00=rt, 01=rd, 10=$ra) |
| ALUSrc | 1 | O | ALU源选择 (1=立即数, 0=寄存器rt) |
| RegSrc[1:0] | 2 | O | 写回寄存器数据选择 (00=ALU结果, 01=内存数据, 10=PC+4) |
| RegWrite | 1 | O | 寄存器写使能 |
| MemWrite | 1 | O | 内存写使能 |
| nPC_sel[1:0] | 2 | O | 下一个 PC 选择 (01=分支, 00=PC+4, 10=跳转$ra) |
| ExtOp | 1 | O | 立即数扩展方式 (1=符号, 0=零) |
| ALUctr[2:0] | 3 | O | ALU 运算类型控制 |

|    指令   |   `func`  |    `op`   | `RegDst<1:0>` | `ALUSrc` | `RegSrc<1:0>` | `RegWrite` | `MemWrite` | `nPC_sel<1:0>` | `ExtOp` | `ALUctr<2:0>` |    功能描述    |
| :-----: | :-------: | :-------: | :------: | :------: | :--------: | :--------: | :--------: | :-------: | :-----: | :-----------: | :--------: |
| **add** | `10 0000` | `00 0000` |     1    |     0    |      00     |      1     |      0     |     00     |    X    |      000      |    R型加法    |
| **sub** | `10 0010` | `00 0000` |     1    |     0    |      00     |      1     |      0     |     00     |    X    |      001      |    R型减法    |
| **ori** |    n/a    | `00 1101` |     0    |     1    |      00     |      1     |      0     |     00     |    0    |      010      |    立即数或    |
|  **lw** |    n/a    | `10 0011` |     0    |     1    |      01     |      1     |      0     |     00     |    1    |      000      |  读内存（Load） |
|  **sw** |    n/a    | `10 1011` |     X    |     1    |      X     |      0     |      1     |     00     |    1    |      000      | 写内存（Store） |
| **beq** |    n/a    | `00 0100` |     X    |     0    |      X     |      0     |      0     |     01     |    X    |      001      |   分支相等跳转   |
| **lui** |    n/a    | `00 1111` |     0    |     1    |      00     |      1     |      0     |     00     |    X    |      011      | 加载立即数到寄存器高位 |
| **nop** | `00 0000` | `00 0000` |     X    |     0    |      X     |      0     |      0     |     00     |    X    |      000      |    无操作指令    |
| **jal** |   n/a    | `00 0011` |  10($ra) |    0     |  10(PC+4)    |      1     |      0     |      10(无条件跳转) |    X     |    000  | 跳转并链接（Jump and Link） |
| **jr**  | `00 1000` | `00 0000` |     X    |     0    |      X     |      0     |      0     |     11(寄存器跳转)     |    X    |      000      | 寄存器跳转（Jump Register） |

###  MIPS.v (顶层模块)

功能: 实例化并连接所有子模块，构成完整的单周期 CPU 数据通路和控制通路。

| 端口名 | 位宽 | 方向 | 功能说明 |
|---|---|---|---|
| clk | 1 | I | 系统时钟 |
| reset | 1 | I | 系统复位 |



## 思考题
1. 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？
   > addr 信号来自执行阶段算出来的有效地址（也就是基址寄存器 + 偏移量），ALU 计算出的内存访问地址
   
   > 地址信号 addr 位数是 [11:2] 而不是 [9:0] 的原因是因为 MIPS 体系结构中，内存地址是**按字节寻址**的，DM 的容量是 4KB = 4096 字节 = 1024 × 32-bit（一个 word = 4 字节），一个地址指向一个word的最低位，。因此，为了访问字边界上的数据，需要将地址的最低两位（[1:0]）舍弃，这样就只剩下高 10 位（[11:2]）用于索引 4KB 内存中的 1024 个字。   
2. 思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。
    > 方式一，记录指令对应的控制信号如何取值（以四个控制信号为例）
    ```verilog
    always @(*) begin
    // default
    {RegWrite, MemRead, MemWrite, ALUop} = 0;
    case(opcode)
        6'b100011: {RegWrite, MemRead, MemWrite, ALUop} = 4'b1_1_0_000; // lw
        6'b101011: {RegWrite, MemRead, MemWrite, ALUop} = 4'b0_0_1_000; // sw
        6'b000000: {RegWrite, MemRead, MemWrite, ALUop} = 4'b1_0_0_010; // R-type
        // ...
    endcase
    end
    ```
    > 方式二，分解指令字段，逐一生成控制信号
    ```verilog
    reg [N-1:0] control_rom [0:63]; // N 是控制字宽度
    initial begin
    control_rom[6'b100011] = {1'b1, 1'b1, 1'b0, 3'b000}; // lw
    // ...
    end

    wire [N-1:0] ctrl = control_rom[opcode];
    // 再拆成各个信号
    assign {RegWrite, MemRead, MemWrite, ALUop} = ctrl;

    ```

3. 在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。
   > 异步复位：复位信号的优先级高于时钟信号，一旦复位信号有效，电路立即进入复位状态，无需等待时钟边沿。
   
   > 同步复位：复位信号的优先级低于时钟信号，只有在时钟边沿到来时，复位信号有效时，电路才进入复位状态。
4. C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。
   > addi 与 addiu  都是将16位有符号立即数进行扩展为32位后与寄存器内容相加，忽略溢出情况下，addi 和 addiu 在忽略溢出的前提下是等价的。 add 与 addu 同理
    
    > 参考MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set 的对应指令的Programming notes部分。