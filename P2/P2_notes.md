# P2课下
参考资料 https://roife.github.io/posts/buaa-co-lab-pre-03/
## 练习1：矩阵乘法 矩阵卷积
- 二维数组写法： `matrix: .word 0: 256`
- 尽量不要以 n-1 作为上限变量判断越界，这样计算二维数组下标会比较麻烦，就把总量设成变量就行。
- 
**出现的小错误：**

- 标签要唯一：  `loop_i_in ` `loop_j_in`等等，
- 复制代码时，**一定注意RAM中的标签名修改**，其他寄存器的标签往往通用
- 函数返回值，需要放在`$v0 $v1`中
- 存储寄存器`$s0` 和 `$a0` 不要搞混，将数组容量存储在s寄存器中，使用时谨慎不要弄混

## 字符串
- 使用一维数组定义即可`str: .space 56`
- 数据类型的大小：int: 1word, 4byte，用 lw/sw，记得 sll $t0, $t0, 2；char: 1byte，用 lb/sb
  
## 函数与递归
- 调用函数是，函数调用处的地址保存在 `$ra` 中。输入保存在 `$a0 ~ $a3`，返回值保存在 `$v0 ~ $v1`（保存不下则放到栈里）。
- 递归函数翻译注意：
  - 只要出现`return;`或者`void`函数结束， 就需要来一遍读取保护的寄存器值

  - 需要保护的寄存器，`$sp`, 在调用函数之后，又用到的变量，如
```C
    symbol[i] = 1;
    dfs(step + 1);
    symbol[i] = 0;
```
  - 其中 i 会在`dfs(step+1)`中再次被修改， 因此需要被保护
  -  重新利用i计算offset

+ **为什么要把传入函数的参数a0转移到t0**
  + 因为，a0往往被打印输出所用，防止混乱
-  **基本结构**
    1. **将需要保护的寄存器压入栈**
    2. 接受传入的参数a0,a1等，**放到临时变量中**
    3. 设置临时变量，i=0等等
    4. 翻译函数主体：注意 
       + if条件句 **条件反转，方便阅读**
       + 注意循环主体使用j语句
    5. 递归语句时， **将需要传入的参数-临时变量t1、t0等，传回到a0、a1等寄存器**，使用 `jal 函数最初的label`，例如：
    ```
    addi $a0, $t0, 1  #! 参数设为step + 1 must use t0, a0 has been covered by the output
    jal dfs    # dfs(step+1)
    ```

    6. 出现return 时（或者void函数结束），就需要翻译如下

    ```asm
    lw   $v0, 1 # 将返回值放入v0,没有返回值就省略这句话
    #--将需要保护的寄存器出栈，放回原寄存器--#
    jr   $ra
    ```   
   - 注意**出栈顺序与入栈顺序相反哦**

    
  