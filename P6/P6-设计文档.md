# 流水线CPU设计文档


## 设计思路
- 分布式译码
- 控制器采用指令驱动型
## 命名规范
- 模块名：级别_模块名，如 F_PC, D_GRF
- 端口名：级别_端口名，如 F_PC_en, D_A1，一些特殊端口可省略级别前缀，如 clk, reset
- 寄存器名：两个级别_寄存器名，如 FD_Instr,
- 主文件中的临时wire信号：小写级别_信号名
- 功能部件 MUX 用 always 实现，转发 MUX 用 assign 语句实现。

## 支持指令集
add, sub, and, or, slt, sltu, lui
addi, andi, ori
lb, lh, lw, sb, sh, sw
mult, multu, div, divu, mfhi, mflo, mthi, mtlo
beq, bne, jal, jr

普通计算类指令：add, sub, **and, or, slt, sltu**, lui, **addi, andi,** ori
乘除槽：**mult, div, divu, mfhi, mflo, mthi, mtlo**
访存类指令：**lb, lh**, lw, **sb, sh,** sw
跳转类指令：beq, **bne**, jal, jr


## Mips （顶层模块） 
略

## CONTROLLER (主控制器)
- **功能**: 根据指令的 opcode 和 funct 生成各级所需的控制信号。


| 端口名     | 位宽 | 方向 | 功能说明                                                     |
| ---------- | ---- | ---- | ------------------------------------------------------------ |
| opcode     | 6    | I    | 指令操作码                                                   |
| funct      | 6    | I    | R 型指令功能码                                               |
| RFWr    | 1    | O    |  寄存器写使能 (传递用)           |
| DMWr    | 1    | O    |  内存写使能 (传递用)              |
| ALUOp  | 3   | O    |  ALU 运算类型 (传递用)          |
| ExtOp   | 1    | O    | 立即数扩展方式 (传递用)        |
| CmpOp   | 3    | O    | 比较操作类型 D级比较信号用于跳转(取代Zero)   |
| Reg_WrSrc | 2    | O    |  寄存器写数据源选择 (传递用)       |
| ALU_BSrc  | 2    | O    |  ALU 第二操作数选择  |
| Reg_WrSel | 2    | O    |  写入寄存器地址选择         |
| T\_use\_RS | 2    | O    |  "RS 消费时间" (送往冒险控制器)    |
| T\_use\_RT | 2    | O    |  "RT 消费时间" (送往冒险控制器)    |

**每一级Controller生成的所需信息不同**
- D级：EXTOp，Reg_WrSrc
- E级：ALU_BSrc, Reg_WrSrc
## F级：IF (取指令) 阶段

本阶段负责获取当前指令。

### F_PC (Program Counter)
- **功能**: 保存当前指令地址。在流水线中，它需要接收下一地址（来自NPC MUX）。

| 端口名 | 位宽 | 方向 | 功能说明 |
| :--- | :--- | :--- | :--- |
| clk | 1 | I | 时钟信号 |
| reset | 1 | I | 同步复位信号 |
| F_PC_en | 1 | I | PC写使能（来自冒险控制器，用于暂停）1为可以写入 |
| F_NPC_in | 32 | I | 下一条指令地址（来自NPC MUX的最终选择） |
| F_PC | 32 | O | 当前PC地址（送往 IM 和 NPC） |



## FD_REG（D级流水线寄存器）
**暂停时本级无需清0，只需要使能信号为0即可保持原值。**
| 端口名 | 位宽 | 方向 | 功能说明 |
|--------|------|------|----------|
| clk    | 1    | I    | 时钟信号 |
| reset  | 1    | I    | 同步复位信号 |
| FD_en  | 1    | I    | 寄存器使能（0=保持/暂停，1=正常更新） |
| **（来自 F 级的输入）** |      |      |          |
| F_Instr | 32 | I  | 来自指令存储器（IM）的 32 位指令 |
| F_PC   | 32 | I  | 来自 IF 级的 PC 值(jal)  |
| **（输出到 D 级的信号）** |      |      |          |
| D_Instr | 32 | O  | 输出到 ID 级的 32 位指令 |
| D_PC   | 32 | O  | 输出到 ID 级的 PC 值  |

**PC值需要一直传递**

## D级：ID (译码/读寄存器) 阶段

本阶段负责译码、读取寄存器堆(RF)以及产生控制信号。

### Splitter (指令译码/拆分)
- **功能**: 将 FD_REG 传来的32位指令拆分为各个字段。
- **注意：该模块有两个实例，一个在D级读取拆分指令，获得rs,rt,rd,i16**
- **另一个在controller里实例，用于生成控制指令，因为实现的是分布式译码**
| 端口名 | 位宽 | 方向 | 功能说明 |
| :--- | :--- | :--- | :--- |
| Instr | 32 | I | 来自 `FD_REG`的指令 |
| opcode | 6 | O | 操作码 (送往相应控制器)  |
| rs | 5 | O | 源寄存器1 (送往 GRF A1) |
| rt | 5 | O | 源寄存器2 (送往 GRF A2 / A3 MUX)  |
| rd | 5 | O | 目的寄存器 (送往 A3 MUX)  |
| funct | 6 | O | 功能码 (送往相应控制器)  |
| i16 | 16 | O | 16位立即数 (送往 EXT) |
| i26 | 26 | O | 26位跳转立即数 (送往 `NPC`) |


### GRF (通用寄存器组)

| 端口名 | 位宽 | 方向 | 功能说明 |
| :--- | :--- | :--- | :--- |
| clk | 1 | I | 时钟信号 |
| reset | 1 | I | 同步复位 |
| A1 | 5 | I | 读端口 1 地址 (来自 `rs`)  |
| A2 | 5 | I | 读端口 2 地址 (来自 `rt`)  |
| RD1 | 32 | O | 读出的数据 1 (Value 1) |
| RD2 | 32 | O | 读出的数据 2 (Value 2) |
| A3 | 5 | I | **W级** 写入地址 (来自 `W_A3`)  |
| WD | 32 | I | **W级** 写入数据 (来自 WB MUX)|
| RFWr | 1 | I | **W级** 写入使能 (来自 W_Controller `W_RFWr`)|

### EXT (立即数扩展单元)
- **功能**: 将 16 位立即数扩展为 32 位。

| 端口名 | 位宽 | 方向 | 功能说明 |
| :--- | :--- | :--- | :--- |
| D_Imm16 | 16 | I | 16位立即数输入 (来自 Splitter) |
| D_ExtOp | 1 | I | 扩展操作选择 (来自 D_Controller) |
| D_E32 | 32 | O | 32位扩展结果 (Value 32) |

### A3_MUX (目的寄存器地址 MUX)
- **功能**: 根据指令类型（如 `P4` 中的 `RegDst` 信号），选择 `rt` 或 `rd` 或 `$ra(31)` 作为目的寄存器地址 `A3` [cite: 452]。

| 端口名 | 位宽 | 方向 | 功能说明 |
| :--- | :--- | :--- | :--- |
| D_rt | 5 | I | rt 寄存器地址 |
| D_rd | 5 | I | rd 寄存器地址 |
| D_RA31 | 5 | I | 31号寄存器，常数 | 
| D_Reg_WrSel | 2 | I | 目的寄存器选择信号 (来自 D_Controller) |
| D_RegDst | 5 | O | 最终的目的寄存器地址 (**一直往后送**)  |

- **注意：D_RegDst 生成后一直流水线传递到W级。**

### D_CMP (ID級比較器)
* **功能**: 在 ID 級執行对**转发过来的数据A1 A2**比較運算（例如 `beq` 的相等比較 ），提前生成分支是否跳轉的信號。

| 端口名 | 位寬 | 方向 | 功能描述 |
| :--- | :--- | :--- | :--- |
| `D_A1` | 32 | I | 來自 `rs` (A1) 的值，**是已處理轉發 (Forwarded) 後的最終值** |
| `D_A2[31:0]` | 32 | I | 來自 `rt` (A2) 的值，**是已處理轉發 (Forwarded) 後的最終值** |
| `CmpOp[2:0]` | 3 | I | 比較操作控制信號（来自 D_Controller） ，例如 `CMP_beq` |
| `D_bjump` | 1 | O | 比較結果 / 分支條件滿足標誌 (1=滿足, 0=不滿足)，此信號將送往 `NPC` 模塊進行下一PC決策 |

**注意：GRF读出的rs/rt值先转发，再连接到CMP和下一级寄存器**

### DF_NPC (Next Program Counter)

功能: 计算下一条指令地址 (PC+4 或分支目标地址)。

| 端口名 | 位宽 | 方向 | 功能说明 |
|---|---|---|---|
| F_PC[31:0] | 32 | I | F级获取的指令地址 |
| D_PC[31:0] | 32 | I | D级获取的流水指令地址，用于跳转PC+8 |
| D_imm26[25:0] | 26 | I | 26位立即数 |
| D_imm16[25:0] | 26 | I | 16位立即数 |
| D_RA[31:0]  | 32 | I | **转发后**$31保存的寄存器地址,**来自A1**|
| nPC_sel[1:0] | 2 | I | 下一 PC 选择信号 |
| `D_bjump` | 1 | I | 分支条件满足标志 (用于 beq 条件判断) |
| NPC[31:0] | 32 | O | 下一条指令地址 |

**注意RA需要先转发（例如汇编中保存寄存器的sp）**

---
## DE_REG（ID/EX 流水线寄存器）
锁存 ID 级（译码）的输出，作为 EX 级（执行）的输入。需传递所有数据和控制信号，并**支持「清空」以处理 `lw` 指令的加载延迟槽**。

| 端口名 | 位宽 | 方向 | 功能说明 |
|--------|------|------|----------|
| clk    | 1    | I    | 时钟信号 |
| reset  | 1    | I    | 同步复位信号 |
| DE_clr | 1    | I    | 寄存器清除（1=清零/插入nop，0=正常） |
| **（数据输入）** |      |      |          |
| D_V1   | 32   | I    | 来自 ID 级的 已转发过的RF 读出值 1（V1） |
| D_V2   | 32   | I    | 来自 ID 级的 已转发过的RF 读出值 2（V2） |
| D_E32  | 32   | I    | 来自 ID 级的 32 位立即数扩展结果 |
| **（地址输入）** |      |      |          |
| D_PC   | 32   | I    | 来自 ID 级的 PC 值 |
| D_A3   | 5   | I     | 来自 ID 级产生的写入寄存器地址 | 
| **（指令输入）包含rt,rd,rs地址）** |      |      |          |
| D_Instr | 32 | I | 来自FD_REG上一级的指令 |
| **（控制输入）** |      |      |          |
| **（数据输出）** |      |      |          |
| E_V1   | 32   | O    | 输出到 EX 级的 V1 |
| E_V2   | 32   | O    | 输出到 EX 级的 V2 |
| E_E32  | 32   | O    | 输出到 EX 级的 E32  |
| **（地址输入）** |      |      |          |
| E_PC   | 32   | O    | 输出到 EX 级的 当前指令地址 |
| E_A3   | 5   | O     | 输出到 EX 级的 写入寄存器地址 | 
| **（指令输出）** |      |      |          |
| E_Instr | 32   |   O   | 输出到EX一级的指令 |
| **（控制输出）** |      |      |          |
| E_Tnew   | 2    | O    | **生成** EX 级的 T_new 值 |

1. **注意暂停操作需要把这里清空**
2. **E_T_new在这里根据指令产生值。**
---

## E级：EX (执行) 阶段

本阶段主要负责算术逻辑运算。

### ALU (算术逻辑单元)
- **功能**: 执行运算。输入端需要**转发MUX**来接收来自 EX, MEM, WB 级的数据。

| 端口名 | 位宽 | 方向 | 功能说明 |
| :--- | :--- | :--- | :--- |
| A | 32 | I |   输入操作数 1 (来自**转发 MUX A**) |
| B | 32 | I |   输入操作数 2 (来自**转发 MUX B**) |
| E_ALUOp | 3 | I | 运算控制信号 (来自**E_Controller**) |
| E_AO | 32 | O | 运算结果 (ALU Out)|

### ALU_B_MUX   
- **功能**：选择ALU B输入端的数据: 转发过的V2 或者 E32。
  
| 端口名 | 位宽 | 方向 | 功能说明 |
| :--- | :--- | :--- | :--- |
| E_V2 | 32 | I | E级的第二个值V2(RD2)|
| E_ALU_BSrc | 2 | I | 选择信号| 
| E_ALUB | 32 | O | 输出到ALUB端的数值  |


### E_WD_MUX   
- **功能**：E级处，选择正确的寄存器写入值，即为转发出的值
这时，能产生正确写入值的指令只有PC类(jal)【**策略矩阵**】

| 端口名 | 位宽 | 方向 | 功能说明 |
| :--- | :--- | :--- | :--- |
| E_PC | 32 | I | 输入E级的指令当前地址|
| E_Reg_WrSrc| 2 | I | 选择信号（只有jal类信号有值，其他均为0 | 
| E_WD | 32 | O | E级处产生的写入值（只可能是PC+8，其他均为0） (**一直往后送**)  |

---
## EM_REG（EX/MEM 流水线寄存器）

| 端口名 | 位宽 | 方向 | 功能说明 |
|--------|------|------|----------|
| clk    | 1    | I    | 时钟信号 |
| reset  | 1    | I    | 同步复位信号 |
| **（指令输入）** |      |      |          |
| E_Instr | 32   |   O   | 来自EX一级的指令 |
| **（数据输入）** |      |      |          |
| E_AO    | 32   | I    | 来自 EX 级的 ALU 运算结果  |
| E_V2    | 32   | I    | 来自 EX 级的 V2 值（用于 sw 写入 DM） |
| E_PC    | 32   | I    | 来自 EX 级的 当前指令地址 |
| **（地址输入）** |      |      |          |
| E_A3    | 5    | I    | 来自 EX 级的 A3（目的寄存器）地址  |
| **（控制输入）** |      |      |          |
| E_Tnew    | 2    | I    | 来自 EX 级的 T_new 值 |
| **（指令输出）** |      |      |          |
| M_Instr | 32   |   O   | 输出到 MWM 级的指令 |
| **（数据输出）** |      |      |          |
| M_AO    | 32   | O    | 输出到 MEM 级的 ALU 结果 |
| M_V2    | 32   | O    | 输出到 MEM 级的 V2 值 |
| M_PC    | 32   | O    | 输出到 MEM 级的 当前指令地址（用于 jal 回写）  |
| **（地址输出）** |      |      |          |
| M_A3    | 5    | O    | 输出到 MEM 级的 A3 地址 |
| M_Tnew    | 2    | O    | 输出到 MEM 级的 T_new 值 **需要减一** |

1. **记得Tnew -1**
   
---

## M级：MEM (访存) 阶段

本阶段负责与数据存储器交互。


### M_WD_MUX   
- **功能**：M级处，选择正确的寄存器写入值，即为可能转发出的值
这时，能产生正确写入值的指令有PC类(jal)和ALU类【**策略矩阵**】

| 端口名 | 位宽 | 方向 | 功能说明 |
| :--- | :--- | :--- | :--- |
| M_PC | 32 | I | 输入E级的指令当前地址|
| M_AO | 32 | I | 上一级计算的ALU结果 |    
| E_Reg_WrSrc| 2 | I | 选择信号 | 
| E_WD | 32 | O | E级处产生的写入值（**只可能是PC+8或ALU结果，其他为0**）  |

---
## MW_REG（MEM/WB 流水线寄存器）

流水线最后一级锁存。

| 端口名 | 位宽 | 方向 | 功能说明 |
|--------|------|------|----------|
| clk    | 1    | I    | 时钟信号 |
| reset  | 1    | I    | 同步复位信号 |
| **（指令输入）** |      |      |          |
| M_Instr | 32   |   O   | 来自 MEM 级的指令 |
| **（数据输入）** |      |      |          |
| M_AO    | 32   | I    | 来自 MEM 级的 ALU 结果 |
| M_RD    | 32   | I    | 来自 MEM 级的 DM 读出数据  |
| M_PC    | 32   | I    | 来自 MEM 级的 PC 值 |
| **（地址输入）** |      |      |          |
| M_A3    | 5    | I    | 来自 MEM 级的 A3（目的寄存器）地址 |
| **（指令输出）** |      |      |          |
| W_Instr | 32   |   O   | 输出到 WB 级的指令 |
| **（数据输出）** |      |      |          |
| W_AO    | 32   | O    | 输出到 WB 级的 ALU 结果  |
| W_RD    | 32   | O    | 输出到 WB 级的 DM 读出数据  |
| W_PC    | 32   | O    | 输出到 WB 级的 PC 值|
| **（地址输出）** |      |      |          |
| W_A3    | 5    | O    | 输出到 WB 级的 A3 地址 |


1. **Tnew一定减为0了**
---
## W级：WB (回写) 阶段

本阶段负责将最终结果写回寄存器堆(GRF)。

### WB_MUX (回写 MUX)
-   **功能**: 选择写回 GRF 的数据来源：是来自 ALU 的结果 (`M_AO`) 还是来自 DM 的结果 (`M_RD`)  还是 PC+8 (`M_PC`)(jal)

| 端口名 | 位宽 | 方向 | 功能说明 |
| :--- | :--- | :--- | :--- |
| AO_W | 32 | I | 来自 `MEM/WB` 的 ALU 结果 |
| DR_W | 32 | I | 来自 `MEM/WB` 的内存读出数据 |
| M_PC | 32 | I | 当前指令值 | 
| Reg_WrSel | 2 | I | 写回数据源选择信号 (来自 `MEM/WB`) |
| W_WD | 32 | O |   最终写回 RF 的数据  |

---

## 流水线专用部件

这些是实现流水线所**必须新增**的模块。

### 数据冲突表

### 表格1：$T_{\text{use}}$ 表
|      | $T_{\text{use}}$ |         |
| :--- | :--------------- | :------ |
|      | rs               | rt      |
| add  | 1                | 1       |
| sub  | 1                | 1       |
| andi | 1                |         |
| ori  | 1                |         |
| lw   | 1                |         |
| sw   | 1                | 2       |
| beq  | 0                | 0       |
| jr   | 0                |         |
|      |                  |         |
|      | {0,1}            | {0,1,2} |


### 表格2：指令、功能部件与 $T_{\text{new}}$ 表
| 指令 | 功能部件 | $T_{\text{new}}$ |      |      |
| :--- | :------- | :--------------- | :--- | :--- |
|      |          | E                | M    | W    |
| add  | ALU      | 1                | 0    | 0    |
| sub  | ALU      | 1                | 0    | 0    |
| andi | ALU      | 1                | 0    | 0    |
| ori  | ALU      | 1                | 0    | 0    |
| lw   | DM       | 2                | 1    | 0    |
| lui  | ALU      | 1                | 0    | 0    |
| sw   |          |                  |      |      |
| beq  |          |                  |      |      |
| jal  | PC       | 0                | 0    | 0    |


### 表格3：策略矩阵
#### rs策略矩阵
| $T_{\text{use}} \ \backslash \ T_{\text{new}}$ | E（ALU） | E（DM） | E（PC） | M（ALU） | M（DM） | M（PC） | W（ALU） | W（DM） | W（PC） |
| :--------------------------------------------- | :------- | :------ | :------ | :------- | :------ | :------ | :------- | :------ | :------ |
| 0                                              | S        | S       | F       | F        | S       | F       | F        | F       | F       |
| 1                                              | F        | S       | F       | F        | F       | F       | F        | F       | F       |


#### rt策略矩阵
| $T_{\text{use}} \ \backslash \ T_{\text{new}}$ | E（ALU） | E（DM） | E（PC） | M（ALU） | M（DM） | M（PC） | W（ALU） | W（DM） | W（PC） |
| :--------------------------------------------- | :------- | :------ | :------ | :------- | :------ | :------ | :------- | :------ | :------ |
| 0                                              | S        | S       | F       | F        | S       | F       | F        | F       | F       |
| 1                                              | F        | S       | F       | F        | F       | F       | F        | F       | F       |
| 2                                              | F        | F       | F       | F        | F       | F       | F        | F       | F       |

### HazardCtrl (数据冲突控制器)
-   **功能**: 核心模块。根据**生产-消费模型**   和**策略矩阵** 生成暂停和转发信号。

| 端口名 | 位宽 | 方向 | 功能说明 |
| :--- | :--- | :--- | :--- |
| D_T_use_RS, D_T_use_RT | 2 | I |   D级指令的 "消费时间" |
| E_Tnew, M_Tnew | 2 | I |   E级和M级指令的 "生产时间" |
| D_A1, D_A2 | 5 | I | D级读取的寄存器地址 |
| E_A3, M_A3| 5 | I |   E, M级的目的寄存器地址  |
| E_RFWr, M_RFWr| 1 | I |   E, M级的写使能信号 |
| Stall | 1 | O |   暂停信号 (送往 PC 和 IF/ID 寄存器)  |
| Fwd_D_RS_Sel | 2 | O |   D级rs通路的比较/转发选择（0=原值，1=来自E，2=来自M） |
| Fwd_D_RT_Sel | 2 | O |   D级rt通路的比较/转发选择信号 |
| E_Fwd_A_Sel | 2 | O |   ALU A端转发MUX控制信号 |
| E_Fwd_B_Sel | 2 | O |   ALU B端转发MUX控制信号 |
| Fwd_M_WD_Sel | 2 | O |   DM写数据端口的前递MUX控制（0=E_V2，1=E结果，2=WB） |

<img src="./assets/image-20251125150822618.png" alt="image-20251125150822618" style="zoom:50%;" />

### Forwarding_MUXes (转发 MUX)

-   **功能**: 位于 EX 级 ALU 的输入端，根据冒险控制器的信号，选择正确的数据来源。
-   D级的RF后 rs、rt各需要一个转发：Fwd_D_RS、Fwd_D_RT
-   E级的ALU A B端各需要一个转发: Fwd_E_ALUA、Fwd_E_ALUB
-   M级 DM处的WD输入需要一个转发: Fwd_M_WD
转发信息来源：

- E_WD: EX/MEM级是jal类指令，在该级产生正确结果，需要传递PC+8（其他的指令Tnew != 0）
- M_WD: MEM/WB是jal、计算类指令，在该级产生正确结果，需要传递PC+8/ALU结果
- W_WD: 所有指令在该级已经产生正确结果，需要传递ALU结果。

以Fwd_E_ALUB为例
| 端口名 | 位宽 | 方向 | 功能说明 |
| :--- | :--- | :--- | :--- |
| E_V2 | 32 | I |   来源0：ID/EX 寄存器的 V2 值 (默认)  |
| M_WD | 32 | I |   来源2：MEM/WB 的写入数据 |
| W_WD | 32 | I |   来源3：WB 的写入数据 |
| Fwd_B_Sel | 2 | I | 选择信号 (来自 Hazard Controller) |
| ALU_B | 32 | O |   最终送往 ALU B端的数据 [cite: 457] |


# 思考题

**1. 为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？**

> 乘除法运算相比于简单的加减逻辑运算，其电路结构更复杂，计算耗时也更长。如果将其强行整合进 ALU，会拉长整个 ALU 的关键路径延迟，导致 CPU 的主频被迫降低，影响所有指令的执行效率。将 MDU 独立出来，可以让简单的指令继续以单周期的高速在 ALU 中流转，而复杂的乘除法在后台多周期运行，实现并行处理。至于独立的 HI、LO 寄存器，是因为两个 32 位数相乘会产生 64 位的结果，单个 32 位的通用寄存器无法容纳，且如果将其写入通用寄存器堆，会占用写端口，导致与后续指令产生结构冲突，因此使用专用的内部寄存器来存储结果最为合理。

**2. 真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。**

> 在真实的现代高性能 CPU 中，乘除法通常不会像我们实验中这样简单地阻塞流水线。硬件上往往采用更高效的算法电路，比如使用 Booth 算法、华莱士树（Wallace Tree）来加速乘法，或者使用 SRT 算法加速除法。更进一步地，真实的乘除法部件本身往往也是流水线化的，支持“发射”多条乘法指令，即上一条乘法还没算完，下一条就可以开始计算，通过乱序执行或记分牌机制来管理依赖，从而极大地掩盖了长延时带来的性能损失。

**3. 请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？**

> 在我的设计中，Busy 信号是 MDU 处于“忙碌状态”的标志。为了防止数据错误，我采用了“D 级拦截”的策略。具体来说，当 MDU 正在运算（Busy 为 1）或者刚刚启动（Start 为 1）时，如果译码阶段（D 级）检测到当前指令是 mult、div、mfhi、mflo 等与乘除法相关的指令，冒险控制器就会产生阻塞信号。这个信号会冻结 PC 和 F/D 流水线寄存器，同时清空进入 E 级的数据流（Flush），直到 Busy 信号拉低。这样既保证了正在进行的运算不被打断，也保证了后续指令能读到正确的运算结果，同时不影响那些与 MDU 无关的指令（如 add、beq）正常流转。

**4. 请问采用字节使能信号的方式处理写指令有什么好处？**

> 采用字节使能信号（Byte Enable）最大的好处在于统一了数据通路的接口设计，增强了模块的规范性。如果不使用这种方式，我们可能需要为 sw、sh、sb 分别设计不同的写逻辑甚至是不同的存储器接口。而引入 4 位使能信号后，无论是写字、半字还是字节，CPU 只需要统一向 DM 发送 32 位的数据和 4 位的掩码。DM 内部只需要根据掩码判断哪一部分数据有效并进行写入。这种抽象屏蔽了不同位宽写入的复杂性，使得顶层模块与存储器的交互逻辑变得非常清晰且易于扩展。

**5. 我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？效率问题？**

> 实际上，无论进行何种位宽的操作，我们与 DM 交互的数据接口物理上都是 32 位的。在按字节写时，我们通过“复制填满”的方式将单字节数据扩展到 32 位总线上的每一个字节通道，配合使能信号写入；按字节读时，我们也是一次性读出 32 位字，再通过扩展模块截取所需字节。因此，从硬件访存的角度看，按字节读写的物理耗时与按字读写是一样的，并不会更快。但在软件层面，按字节操作允许我们更紧凑地存储数据（如字符串），极大地节省内存空间，在处理字符密集型任务时，虽然单条指令效率没变，但整体的空间效率和缓存命中率可能会更高。

**6. 为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？**

> 为了对抗 P6 的复杂性，我大量使用了宏定义（Define）和模块化封装的手段。在译码阶段，我没有在冒险控制器里直接使用具体的 Opcode，而是在 Controller 中将指令抽象为功能信号（如 MDU\_related、T\_use 时间等）。这种“高内聚”的设计让 Hazard Unit 不需要关心具体指令是谁，只需要关心“它是否需要 MDU”或者“它什么时候产生结果”。这极大地简化了冲突检测逻辑，当后续需要增加新指令时，我只需要在 Controller 里修改，而不需要改动复杂的冒险判断逻辑，降低了出错的概率。

**7. 在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？**

> 我主要遇到了三类冲突：计算类指令的数据冒险、乘除法结构冒险以及访存相关的数据冒险。对于普通的 ALU 计算冲突（如 add 后紧跟 sub），我通过在 E、M、W 级建立完整的数据转发通路来解决；对于 Load-Use 冲突（lw 后紧跟计算），转发无法解决，我通过冒险控制器检测 T\_use 和 T\_new 的关系来插入气泡阻塞流水线；对于 MDU 冲突，即乘法未结束时后续指令试图操作 HI/LO 寄存器，我通过检测 Busy 信号在 D 级强制阻塞相关指令。测试时我构造了诸如“mult 后紧跟 mfhi”、“lw 后紧跟 add”等序列来专门验证这些机制的有效性。

**8. 构造测试样例的策略与强测效果？**

>我主要采用了定向构造的策略，重点是为了确保覆盖到流水线中最容易出错的硬性冲突。我手动构造了连续数据冒险序列，比如一条 lw 指令后立即生成一条使用该寄存器的 add 指令，以保证 Load-Use 停顿逻辑被触发。同时，我严格控制了 MDU 相关指令的间距，例如在 mult 指令的下一条指令就生成 mfhi，用最短的路径来验证 MDU 的 Busy 阻塞和 mflo 转发是否能够正确处理数据依赖和结构冒险，避免关键路径的 Bug 被随机测试所遗漏。





