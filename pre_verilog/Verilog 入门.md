# Verilog 入门
## 常见错误汇总
+ always模块中不能给wire类型赋值
+ assign语句中只能给wire类型赋值（或者默认新建）
+ 为所有的 if 语句都写出相应的 else 分支。


## **硬件描述语言**

+ **模块** 行为建模与结构建模
+ 模拟
+ **综合**，分为**可综合模块**与**测试程序**(testbench)

## 变量声明

### 向量-位选表达式



大小端顺序！
+ 因为 `input [4:7] b`不仅决定了位宽还决定了方向，例如定义为[4:7] 的 b 信号，四个管脚分别为 4，5，6，7，在使用中只能正向接，不能反向接

部分选择符
+ `+:` `-:` 可以使用变量， 但是普通位选`:`不能使用变量

### Wire

+ 使用未经声明的变量不会导致错误。变量未经声明即使用时默认为 1 位 wire 型变量。
+ 声明 wire 型向量：`wire [num1:num2] a`（其中 `num1,num2` 为整数常量），则 `num1,num2` 的值可以是负数，且 `num1、num2 `中的较大值可以在前也可以在后。(表示位数的下标分别是什么，小端还是大端)

### Reg

`Reg` 型是寄存器数据类型，具有**存储**功能。它**也分为标量和向量**，类似 `wire` 型

**`reg` 型变量不能使用 `assign` 赋值**

可以用`Reg`变量数组来建模储存器

+ `reg [31:0] mem [0:1023];`，其中**前面的中括号内为位宽，后面的中括号内为存储器数量**、
+ 引用操作访问存储器型数据元素，例如 `mem[2]` 就是访问 `mem` 中的第 3 个元素

### 数字

**<位宽>'<进制>(b/o/h/d)值>**  `10'd100` 表示10位宽的十进制数100

+ 数值中间不能加符号，但可以这样 `-8'd5`
+ Verilog 中表示有符号数需要加 $signed()

+ 省略位宽时采用默认位宽（与机器有关，一般为 **32 位**）

+ 省略进制时默认为**十进制**

+ 值部分可以用下划线分开提高可读性，如 `16'b1010_1011_1111_1010`。

`x` 为不定值，当某一二进制位的值不能确定时出现，变量的**默认初始值为 `x`**。

`z` 为高阻态，代表**没有连接到有效输入上**。

### Parameter 常量

`parameter 标识符 = 表达式`**在编译时确认值的常量**

+ 可以理解为，在 Logisim 中 MUX 元件的位宽和输入管脚数都是可变的，但是我们具体搭建的模块所使用的实例化的 MUX，其位宽和管脚数都是确定的。

# 组合逻辑建模
### Assign语句-连续赋值
``` verilog
assign a = b;
```
本质：**用一个信号来驱动另一个信号**，**类似于电路与逻辑门的连接**，让左侧变量始终等于右侧

+ **只能wire类型**可以被assign
+ 未被定义的变量**自动设为wire类型**
+ 左右两侧位宽不一致时，会对右侧变量进行扩展或截断，使之与左侧变量位宽相等。如
``` verilog
  output [3:0] Out;
  wire d1, d2;
  assign Out = {d1,d2}; //右侧不足 4 位，会进行零扩展

  // assign Out[1:0] = {d1,d2}; //! 错误，会导致剩下两位为x

  //或者全部分配
  assign Out[1:0] = {d1, d2};
  assign Out[3:2] = 2'b0;
```

### 注意的一些运算符
信号拼接运算符`{}`
`{a, b[3:0], w, 3'b101};`
`{4{w}} -- {w,w,w,w};`


单目位运算符，可以对操作数的每一位汇总运算，如`reg[31:0] B; wire A; assign A = &B;`

# 时序逻辑建模

**时序逻辑与门电路混合使用时，要注意区分，不能混用**

## Always 语块

``` verilog
  always @(posedge clk, negedge clk2)  // 表示在 clk 上升沿或clk2下降沿触发后面的语句块
  always @(a) //变量 a 发生变化时执行、
  always @ * //对语句块内所有信号的变化敏感,建模组合逻辑。
  always // 反复执行，产生一些周期性的信号
  begin
  // 一些操作
```
+ 条件： **只要有其中一个条件被触发，always 之后的语句都会被执行。**
+ **在多个 always 块中对同一个变量进行赋值的代码是不可综合的。**
+ **内部不能对wire类型赋值**

## Initial 语块
+ 仿真中用于初始赋值，不可综合
```C
  reg a;

  initial begin
      a = 0;
  end
```
## if else case
## for循环
int、reg类型都可以作为循环变量
+ 注意！！reg类型需要合理设置位宽，与终止条件一致，**否则会死循环**
+ 建议：用常数作为终止条件，多加一个不超过位宽的条件
+ 不能`i++`哦！
## 阻塞赋值与非阻塞赋值
+ 阻塞赋值 `=` 顺序执行
+ 非阻塞赋值 `<=` 并行执行（在上一阻塞执行之后）

# 测试test bench

``` verilog
initial begin
    ...
end
always #1 clk = ~clk; //时序逻辑控制
```

#
0 0 0 1

temp | A | B | output
0 | 1 | X | 1
0 | 0 | X | 0
