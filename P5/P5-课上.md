# P5 课上准备

## 跳转类指令


有条件链接（即`GPR[31] ← PC + 8`是否有条件）：

如果有条件链接，需要在D_A3_sel的MUX处，中的`RD_RA`分支中，添加对条件的判断：
```verilog
// D stage A3_Sel mux
    reg [4:0] d_a3_r;  
    always @(*) begin
        case (d_reg_wr_sel)
            `RD_RD: d_a3_r = d_rd;
            `RD_RT: d_a3_r = d_rt;
            `RD_RA: begin
                // 【重点修改】在这里拦截！
                // 如果是 bezal 指令，并且条件不满足（没跳），则强行改成写 $0
                if (is_bezal && !D_bjump) 
                    d_a3_r = 5'd0;
                else 
                    d_a3_r = 5'd31; // jal 或 bezal 跳转成功时，写 31
            end
            default: d_a3_r = 5'd0;
        endcase
    end
    assign d_a3 = d_a3_r;
```

+ 将CMP的信号，向后传入到E/M级，根据题意进行操作

+ 如果一个条件操作时是“不写” 那么就写到0号寄存器

  

清空延迟槽：
1. 添加一个新的flush信号 `flush_check`，由CMP根据题目条件生成。
   + `assign flush_check = (CMPOp == bonall? && !b_jump)`
 + 
2. 只需要清空FD寄存器即可！因为此时分支指令进入E级，FD级进入一个延迟槽指令（清空它即可）
3. 确保不在阻塞状态(`!stall`)，因为阻塞状态下FD_REG中不是延迟槽指令，是之前暂停的指令。
   + `FD_REG_Flush = (flush_check && !Stall)`

## 条件存储
1. **修改stall:**如果 D 级的指令要读寄存器，而且后面的新指令**可能**要写这个寄存器，那么就 stall
   + 在所有stall信号表达式中判断寄存器相等的条件中，修改为`(check_E ? (D_A1 == E_A3 | D_A1 == 5'd31) : D_A1 == E_A3)` 其中check_E为是否是新指令
   + **课上把D级opcode/funct 传过来**
2. 在W级生成一个**判断信号**
3. 根据判断信号+是这个指令信号 修改W stage wd sel mux 内逻辑
     === 三个等于号可以让浮空值 Z 和错误值 X 参与比较判断
4. 当写入地址在E级产生，或者写入内容在E/M级就产生了，此时需要修改相应MUX,转发MUX
```verilog
    always @(*) begin
        case (d_reg_wr_sel)
            `RD_RD: d_a3_r = d_rd;
            `RD_RT: d_a3_r = d_rt;
            `RD_RA: d_a3_r = 5'd31; 
            //! 可在这里修改跳转分支类指令
            `RD_XXXSpecial: begin
                if(check === 1'd1) d_a3_r = ...;
            end
            default: d_a3_r = 5'd0;
        endcase
    end
```

+ 考虑条件转发，在转发前加入对应级`Tnew == 0`